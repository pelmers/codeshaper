{"version":3,"file":"algos_entry-dom_ts-generator_ts-reshape_ts.bundle.js","sources":["webpack:///./algos/entry-dom.ts","webpack:///./generator.ts","webpack:///./reshape.ts"],"sourcesContent":["import { DEFAULT_HEIGHT_WIDTH_RATIO, ModeType } from '../constants';\nimport { drawCodeCommon } from './drawCode';\n\nconst pica = import('pica');\n\n// Load the given image uri to an invisible canvas and return the canvas and its 2d context\n// Also resize the picture to make its pixel count as close to targetSize as possible\nasync function loadImageToCanvas(imageFileUri: string, targetSize: number) {\n    // First load the image onto an invisible canvas\n    const source = document.createElement('canvas');\n    const ctx = source.getContext('2d')!;\n    await new Promise<void>((resolve, reject) => {\n        const handler = () => {\n            source.width = Math.floor(image.width);\n            source.height = Math.floor(image.height);\n            ctx.drawImage(image, 0, 0, source.width, source.height);\n            resolve();\n        };\n        const image = new Image();\n        image.onload = handler;\n        image.onerror = reject;\n        image.src = imageFileUri;\n    });\n    const target = document.createElement('canvas');\n    // Find the ratio to get from source dimensions to target size\n    // math check: e.g. target = 16, s.w = s.h = 2, then ratio = 2 as expected\n    const ratio = Math.sqrt(targetSize / (source.width * source.height));\n    target.width = Math.round(\n        source.width * ratio * Math.sqrt(DEFAULT_HEIGHT_WIDTH_RATIO)\n    );\n    target.height = Math.round(\n        (source.height * ratio) / Math.sqrt(DEFAULT_HEIGHT_WIDTH_RATIO)\n    );\n    const resizer = (await pica).default();\n    await resizer.resize(source, target);\n    return { canvas: target, ctx: target.getContext('2d')! };\n}\n\nexport async function drawCode(\n    code: string,\n    imageFileUri: string,\n    mode: ModeType,\n    cutoff: number,\n    invert: boolean\n): Promise<string> {\n    console.time('code shaping');\n    const result = await drawCodeCommon(\n        code,\n        imageFileUri,\n        mode,\n        cutoff,\n        invert,\n        loadImageToCanvas\n    );\n    console.timeEnd('code shaping');\n    return result;\n}\n\n// improvement idea: https://dahtah.github.io/imager/foreground_background.html#k-nearest-neighbour-approach\n","import { CodeGenerator } from '@babel/generator';\nimport { Node } from '@babel/types';\nimport {\n    SPACE_MARKER,\n    OPTIONAL_SPACE_MARKER,\n    UNBREAKABLE_SPACE_MARKER,\n} from './constants';\n\n/**\n * This class generates runnable JS code where replaceable whitespace is\n * annotated with special comments\n */\nexport class WhitespaceMarkerGenerator extends CodeGenerator {\n    constructor(ast: Node) {\n        // Concise replace newlines with spaces, which will let us insert more whitespace markers.\n        super(ast, { compact: true, comments: false });\n    }\n\n    generate() {\n        // @ts-ignore directly accessing the library's code, see https://git.io/J8Xf9\n        const g = this._generator;\n        const oldWord = g.word.bind(g);\n        g.word = (w: string) => {\n            oldWord(w);\n            if (\n                [\n                    'return',\n                    'break',\n                    'continue',\n                    'async',\n                    'throw',\n                    'yield',\n                    'await',\n                ].includes(w)\n            ) {\n                g._unbreakableSpace();\n            }\n        };\n        const oldUnaryExpression = g.UnaryExpression.bind(g);\n        g.UnaryExpression = (node: Node) => {\n            if (\n                'operator' in node &&\n                (node.operator === '+' || node.operator === '-')\n            ) {\n                // Require a space before unary exp because the last symbol could have been a postfix op\n                g._space();\n            }\n            oldUnaryExpression(node);\n        };\n        const oldUpdateExpression = g.UpdateExpression.bind(g);\n        g.UpdateExpression = (node: Node) => {\n            let isPostfix = false;\n            if ('prefix' in node && node.prefix) {\n                g._space();\n            } else {\n                isPostfix = true;\n            }\n            oldUpdateExpression(node);\n            if (isPostfix) {\n                g._space();\n            }\n        };\n        g.space = (force: boolean = false) => {\n            if (\n                (g._buf.hasContent() && !g.endsWith(' ') && !g.endsWith('\\n')) ||\n                force\n            ) {\n                g._space();\n            } else {\n                g._optionalSpace();\n            }\n        };\n        g._space = () => {\n            // This marks a location we can have 1 or more spaces or newline\n            g._append(SPACE_MARKER, true /* queue */);\n        };\n        g._optionalSpace = () => {\n            // This marks a location that can have 0 or more spaces or newline\n            g._append(OPTIONAL_SPACE_MARKER, true /* queue */);\n        };\n        g._unbreakableSpace = () => {\n            // This marks a location that must have a space and NOT a newline\n            g._append(UNBREAKABLE_SPACE_MARKER, true /* queue */);\n        };\n        const oldToken = g.token.bind(g);\n        g.token = (str: string) => {\n            if (str === '=>') {\n                g._unbreakableSpace();\n            }\n            oldToken(str);\n            // instead of smushing tokens together, mark the in-between as allowing spaces\n            g._optionalSpace();\n        };\n        return super.generate();\n    }\n}\n// TODO also deal with typescript(?)\n","import {\n    OPTIONAL_SPACE_MARKER,\n    SPACE_MARKER,\n    UNBREAKABLE_SPACE_MARKER,\n} from './constants';\n\nconst MAX_LINE_WIDTH = Number.MAX_SAFE_INTEGER;\n\n// Compute the minimum length of the code by replacing all spaces\n// with a single space and optional spaces with no space.\nexport function minCodeSize(tokens: TokenType[]): number {\n    return tokens.map(toStr).reduce((prev, cur) => prev + cur.length, 0);\n}\n\ntype SpaceType = 'opt' | 'req' | 'ubn';\ntype TokenType =\n    | {\n          space: SpaceType;\n      }\n    | {\n          text: string;\n      };\n\nfunction minWidth(t: TokenType): number {\n    if ('text' in t) {\n        return t.text.length;\n    } else if (t.space === 'opt') {\n        return 0;\n    }\n    return 1;\n}\n\nfunction toStr(t: TokenType): string {\n    if ('text' in t) {\n        return t.text;\n    } else if (t.space === 'opt') {\n        return '';\n    }\n    return ' ';\n}\n\nfunction isUbn(t: TokenType): boolean {\n    return 'space' in t && t.space === 'ubn';\n}\n\nexport function parseTokens(code: string) {\n    const tokens: TokenType[] = [];\n    for (const betweenBreaks of code.split(UNBREAKABLE_SPACE_MARKER)) {\n        const betweenSpaces = betweenBreaks.split(SPACE_MARKER);\n        for (const sp of betweenSpaces) {\n            const texts = sp.split(OPTIONAL_SPACE_MARKER);\n            for (const text of texts) {\n                tokens.push({ text });\n                tokens.push({ space: 'opt' });\n            }\n            tokens.push({ space: 'req' });\n        }\n        tokens.push({ space: 'ubn' });\n    }\n    return collapseTokens(tokens);\n}\n\n// Fold consecutive spaces to the strongest version\n// i.e. if I have opt - unbreakable - req - opt, then reduce them to one unbreakable\n// Also remove 'text' tokens with empty content and joins together consecutive 'text' nodes\n// At the end of this, the whole program should consist of alternating text-space tokens\nfunction collapseTokens(tokens: TokenType[]) {\n    const stronger = (a: TokenType, b: TokenType): SpaceType => {\n        if ('space' in a && 'space' in b) {\n            if (a.space === 'ubn' || b.space === 'ubn') {\n                return 'ubn';\n            } else if (a.space === 'req' || b.space === 'req') {\n                return 'req';\n            } else {\n                return 'opt';\n            }\n        }\n        throw new Error('unreachable statement');\n    };\n    const reducedTokens: TokenType[] = [];\n    for (let i = 0; i < tokens.length; i++) {\n        const lastToken = reducedTokens[reducedTokens.length - 1];\n        const curToken = tokens[i];\n        if ('text' in curToken && curToken.text === '') {\n            continue;\n        }\n        if (lastToken == null) {\n            reducedTokens.push(curToken);\n        } else if ('space' in lastToken && 'space' in curToken) {\n            lastToken.space = stronger(lastToken, curToken);\n        } else {\n            reducedTokens.push(curToken);\n        }\n    }\n    return reducedTokens;\n}\n\nexport function reshape(\n    tokens: TokenType[],\n    shapeFunction: (row: number) => number\n): string[] {\n    // Enforce a maximum on the line width, even if we get infinity or something from the fn\n    const shapeFn = (row: number) => Math.min(MAX_LINE_WIDTH, shapeFunction(row));\n    // First split the code into tokens that we can join together\n    const lines: TokenType[][] = [[]];\n    let currentLineWidth = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        const currentLineIndex = lines.length - 1;\n        const targetWidth = shapeFn(currentLineIndex);\n        // If the space is unbreakable or it's a token, we must continue this line\n        if (currentLineWidth === 0 || isUbn(t) || 'text' in t) {\n            lines[currentLineIndex].push(t);\n            currentLineWidth += minWidth(t);\n        } else {\n            // Otherwise, we're on a (required or optional) space and could break now\n            // to decide, we will look ahead to see if the next potential breakpoint\n            // would exceed our line's target width\n            let nextBreakpoint = 0;\n            for (let j = i + 1; j < tokens.length; j++) {\n                if ('space' in tokens[j] && !isUbn(tokens[j])) {\n                    break;\n                }\n                nextBreakpoint += minWidth(tokens[j]);\n            }\n            if (currentLineWidth + nextBreakpoint <= targetWidth) {\n                // 明天的烦恼交给明天 (https://youtu.be/8Q5HWGgT1M0)\n                lines[currentLineIndex].push(t);\n                currentLineWidth += minWidth(t);\n            } else {\n                // start a new line since the next break point would exceed the target\n                // Note: if this token is a required space, it becomes optional now\n                lines.push([{ space: 'opt' }]);\n                currentLineWidth = 0;\n            }\n        }\n    }\n    // This portion inserts whitespaces to justify each line to its target width\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        if (shapeFn(i) === MAX_LINE_WIDTH) {\n            // in this case we're putting everything on this line anyway,\n            // don't need to justify 2^53 times (probly not a good idea)\n            continue;\n        }\n        // target value - current size, i.e. number of spaces we want to add\n        let difference = Math.round(shapeFn(i) - minCodeSize(line));\n        // find indices in the line that are spaces\n        const spaceIndices = line\n            // (except last position because spaces at the end of a line aren't visible)\n            .slice(0, line.length - 1)\n            .map((t, idx) => ({ t, idx }))\n            .filter(({ t }) => 'space' in t)\n            .map(({ idx }) => idx);\n        // of course we can't enter the loop unless there are spaces on this line\n        while (spaceIndices.length > 0 && difference > 0) {\n            const idx = spaceIndices[Math.floor(spaceIndices.length * Math.random())];\n            // We've found the index to add space to, we can convert it to text because\n            // we no longer need to know that it was a space\n            line[idx] = { text: `${toStr(line[idx])} ` };\n            difference--;\n        }\n    }\n    return lines.map((line) => line.map(toStr).join(''));\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AAAA;AAEA;;AAOA;AACA;AAQA;AACA;AACA;AAAA;AAEA;AACA;AACA;A;;;;;;;;;;;;;;;AC5DA;AAEA;AAMA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;AClGA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;A","sourceRoot":""}