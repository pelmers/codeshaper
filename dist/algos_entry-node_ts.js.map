{"version":3,"file":"algos_entry-node_ts.js","sources":["webpack:///./vendor/IsThisColourSimilar/Colour.js","webpack:///./algos/common.ts","webpack:///./algos/drawCode.ts","webpack:///./algos/entry-node.ts","webpack:///./algos/intensity.ts","webpack:///./algos/saliency.ts"],"sourcesContent":["/**\n * Colour class\n * Represet the colour object and it's different types (HEX, RGBA, XYZ, LAB)\n * This class have the ability to do the following\n * 1. Convert HEX to RGBA\n * 2. Convert RGB to XYZ\n * 3. Convert XYZ to LAB\n * 4. Calculate Delta E00 between two LAB colour (Main purpose)\n * @author Ahmed Moussa <moussa.ahmed95@gmail.com>\n * @version 2.0\n */\n export class Colour {\n\t/**\n\t * Convert HEX to LAB\n\t * @param {[string]} hex hex colour value desired to be converted to LAB\n\t */\n\tstatic hex2lab(hex) {\n\t\tconst [r, g, b, a] = Colour.hex2rgba(hex);\n\t\tconst [x, y, z] = Colour.rgb2xyz(r, g, b, a);\n\t\treturn Colour.xyz2lab(x, y, z); // [l, a, b]\n\t}\n\t/**\n\t * Convert RGBA to LAB\n\t * @param {[Number]} r     Red value from 0 to 255\n\t * @param {[Number]} g     Green value from 0 to 255\n\t * @param {[Number]} b     Blue value from 0 to 255\n\t */\n\tstatic rgba2lab(r, g, b, a = 1) {\n\t\tconst [x, y, z] = Colour.rgb2xyz(r, g, b, a);\n\t\treturn Colour.xyz2lab(x, y, z); // [l, a, b]\n\t}\n\t/**\n\t * Convert LAB to RGBA\n\t * @param {[Number]} l\n\t * @param {[Number]} a\n\t * @param {[Number]} b \n\t */\n\tstatic lab2rgba(l, a, b) {\n\t\tconst [x, y, z] = Colour.lab2xyz(l, a, b);\n\t\treturn Colour.xyz2rgba(x, y, z); // [r, g, b, a]\n\t}\n\t/**\n\t * Convert HEX to RGBA\n\t * @param {[string]} hex hex colour value desired to be converted to RGBA\n\t */\n\tstatic hex2rgba(hex) {\n\t\tlet c;\n\t\tif (hex.charAt(0) === \"#\") {\n\t\t\tc = hex.substring(1).split('');\n\t\t}\n\t\tif (c.length > 6 || c.length < 3) {\n\t\t\tthrow new Error(`HEX colour must be 3 or 6 values. You provided it ${c.length}`);\n\t\t}\n\t\tif (c.length === 3) {\n\t\t\tc = [c[0], c[0], c[1], c[1], c[2], c[2]];\n\t\t}\n\t\tc = \"0x\" + c.join(\"\");\n\t\tlet r = (c >> 16) & 255;\n\t\tlet g = (c >> 8) & 255;\n\t\tlet b = c & 255;\n\t\tlet a = 1;\n\t\treturn [r, g, b, a];\n\t}\n\t/**\n\t * Convert RGB to XYZ\n\t * @param {[Number]} r     Red value from 0 to 255\n\t * @param {[Number]} g     Green value from 0 to 255\n\t * @param {[Number]} b     Blue value from 0 to 255\n\t * @param {Number} [a=1]   Obacity value from 0 to 1 with a default value of 1 if not sent\n\t */\n\tstatic rgb2xyz(r, g, b, a = 1) {\n\t\tif (r > 255) {\n\t\t\t// console.warn(\"Red value was higher than 255. It has been set to 255.\");\n\t\t\tr = 255;\n\t\t} else if (r < 0) {\n\t\t\t// console.warn(\"Red value was smaller than 0. It has been set to 0.\");\n\t\t\tr = 0;\n\t\t}\n\t\tif (g > 255) {\n\t\t\t// console.warn(\"Green value was higher than 255. It has been set to 255.\");\n\t\t\tg = 255;\n\t\t} else if (g < 0) {\n\t\t\t// console.warn(\"Green value was smaller than 0. It has been set to 0.\");\n\t\t\tg = 0;\n\t\t}\n\t\tif (b > 255) {\n\t\t\t// console.warn(\"Blue value was higher than 255. It has been set to 255.\");\n\t\t\tb = 255;\n\t\t} else if (b < 0) {\n\t\t\t// console.warn(\"Blue value was smaller than 0. It has been set to 0.\");\n\t\t\tb = 0;\n\t\t}\n\t\tif (a > 1) {\n\t\t\t// console.warn(\"Obacity value was higher than 1. It has been set to 1.\");\n\t\t\ta = 1;\n\t\t} else if (a < 0) {\n\t\t\t// console.warn(\"Obacity value was smaller than 0. It has been set to 0.\");\n\t\t\ta = 0;\n\t\t}\n\t\tr = r / 255;\n\t\tg = g / 255;\n\t\tb = b / 255;\n\t\t// step 1\n\t\tif (r > 0.04045) {\n\t\t\tr = Math.pow(((r + 0.055) / 1.055), 2.4);\n\t\t} else {\n\t\t\tr = r / 12.92;\n\t\t}\n\t\tif (g > 0.04045) {\n\t\t\tg = Math.pow(((g + 0.055) / 1.055), 2.4);\n\t\t} else {\n\t\t\tg = g / 12.92;\n\t\t}\n\t\tif (b > 0.04045) {\n\t\t\tb = Math.pow(((b + 0.055) / 1.055), 2.4);\n\t\t} else {\n\t\t\tb = b / 12.92;\n\t\t}\n\t\t// step 2\n\t\tr = r * 100;\n\t\tg = g * 100;\n\t\tb = b * 100;\n\t\t// step 3\n\t\tconst x = (r * 0.4124564) + (g * 0.3575761) + (b * 0.1804375);\n\t\tconst y = (r * 0.2126729) + (g * 0.7151522) + (b * 0.0721750);\n\t\tconst z = (r * 0.0193339) + (g * 0.1191920) + (b * 0.9503041);\n\t\treturn [x, y, z];\n\t}\n\t/**\n\t * Convert XYZ to RGBA\n\t * @param {[Number]} x\n\t * @param {[Number]} y\n\t * @param {[Number]} z\n\t */\n\tstatic xyz2rgba(x, y, z) {\n\t\tlet varX = x / 100;\n\t\tlet varY = y / 100;\n\t\tlet varZ = z / 100;\n\n\t\tlet varR = (varX *  3.2404542) + (varY * -1.5371385) + (varZ * -0.4985314);\n\t\tlet varG = (varX * -0.9692660) + (varY *  1.8760108) + (varZ * 0.0415560);\n\t\tlet varB = (varX *  0.0556434) + (varY * -0.2040259) + (varZ * 1.0572252);\n\n\t\tif ( varR > 0.0031308 ) {\n\t\t\tvarR = 1.055 * Math.pow(varR, (1 / 2.4) ) - 0.055;\n\t\t} else {\n\t\t\tvarR = 12.92 * varR;\n\t\t}\n\t\tif ( varG > 0.0031308 ) {\n\t\t\tvarG = 1.055 * Math.pow(varG, (1 / 2.4) ) - 0.055;\n\t\t} else {\n\t\t\tvarG = 12.92 * varG;\n\t\t}\n\t\tif ( varB > 0.0031308 ) {\n\t\t\tvarB = 1.055 * Math.pow(varB, (1 / 2.4) ) - 0.055;\n\t\t} else {\n\t\t\tvarB = 12.92 * varB;\n\t\t}\n\n\t\tlet r = Math.round(varR * 255);\n\t\tlet g = Math.round(varG * 255);\n\t\tlet b = Math.round(varB * 255);\n\n\t\treturn [r, g, b, 1];\n\t}\n\t/**\n\t * Convert XYZ to LAB\n\t * @param {[Number]} x Value\n\t * @param {[Number]} y Value\n\t * @param {[Number]} z Value\n\t */\n\tstatic xyz2lab(x, y, z) {\n\t\t// using 10o Observer (CIE 1964)\n\t\t// CIE10_D65 = {94.811f, 100f, 107.304f} => Daylight\n\t\tconst referenceX = 94.811;\n\t\tconst referenceY = 100;\n\t\tconst referenceZ = 107.304;\n\t\t// step 1\n\t\tx = x / referenceX;\n\t\ty = y / referenceY;\n\t\tz = z / referenceZ;\n\t\t// step 2\n\t\tif (x > 0.008856) {\n\t\t\tx = Math.pow(x, (1 / 3));\n\t\t} else {\n\t\t\tx = (7.787 * x) + (16 / 116);\n\t\t}\n\t\tif (y > 0.008856) {\n\t\t\ty = Math.pow(y, (1 / 3));\n\t\t} else {\n\t\t\ty = (7.787 * y) + (16 / 116);\n\t\t}\n\t\tif (z > 0.008856) {\n\t\t\tz = Math.pow(z, (1 / 3));\n\t\t} else {\n\t\t\tz = (7.787 * z) + (16 / 116);\n\t\t}\n\t\t// step 3\n\t\tconst l = (116 * y) - 16;\n\t\tconst a = 500 * (x - y);\n\t\tconst b = 200 * (y - z);\n\t\treturn [l, a, b];\n\t}\n\t/**\n\t * Convert LAB to XYZ\n\t * @param {[Number]} l\n\t * @param {[Number]} a\n\t * @param {[Number]} b\n\t */\n\tstatic lab2xyz(l, a, b) {\n\t\t// using 10o Observer (CIE 1964)\n\t\t// CIE10_D65 = {94.811f, 100f, 107.304f} => Daylight\n\t\tconst referenceX = 94.811;\n\t\tconst referenceY = 100;\n\t\tconst referenceZ = 107.304;\n\n\t\tlet varY = ( l + 16 ) / 116;\n\t\tlet varX = a / 500 + varY;\n\t\tlet varZ = varY - b / 200;\n\n\t\tif ( Math.pow(varY, 3)  > 0.008856 ) {\n\t\t\tvarY = Math.pow(varY, 3);\n\t\t} else {\n\t\t\tvarY = ( varY - 16 / 116 ) / 7.787;\n\t\t}\n\t\tif ( Math.pow(varX, 3)  > 0.008856 ) {\n\t\t\tvarX = Math.pow(varX, 3);\n\t\t} else {\n\t\t\tvarX = ( varX - 16 / 116 ) / 7.787;\n\t\t}\n\t\tif ( Math.pow(varZ, 3)  > 0.008856 ) {\n\t\t\tvarZ = Math.pow(varZ, 3);\n\t\t} else {\n\t\t\tvarZ = ( varZ - 16 / 116 ) / 7.787;\n\t\t}\n\n\t\tlet x = varX * referenceX;\n\t\tlet y = varY * referenceY;\n\t\tlet z = varZ * referenceZ;\n\n\t\treturn [x, y, z];\n\t}\n\t/**\n\t * The difference between two given colours with respect to the human eye\n\t * @param {[type]} l1 Colour 1\n\t * @param {[type]} a1 Colour 1\n\t * @param {[type]} b1 Colour 1\n\t * @param {[type]} l2 Colour 2\n\t * @param {[type]} a2 Colour 2\n\t * @param {[type]} b2 Colour 2\n\t */\n\tstatic deltaE00(l1, a1, b1, l2, a2, b2) {\n\t\t// Utility functions added to Math Object\n\t\tMath.rad2deg = function(rad) {\n\t\t\treturn 360 * rad / (2 * Math.PI);\n\t\t};\n\t\tMath.deg2rad = function(deg) {\n\t\t\treturn (2 * Math.PI * deg) / 360;\n\t\t};\n\t\t// Start Equation\n\t\t// Equation exist on the following URL http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html\n\t\tconst avgL = (l1 + l2) / 2;\n\t\tconst c1 = Math.sqrt(Math.pow(a1, 2) + Math.pow(b1, 2));\n\t\tconst c2 = Math.sqrt(Math.pow(a2, 2) + Math.pow(b2, 2));\n\t\tconst avgC = (c1 + c2) / 2;\n\t\tconst g = (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7)))) / 2;\n\n\t\tconst a1p = a1 * (1 + g);\n\t\tconst a2p = a2 * (1 + g);\n\n\t\tconst c1p = Math.sqrt(Math.pow(a1p, 2) + Math.pow(b1, 2));\n\t\tconst c2p = Math.sqrt(Math.pow(a2p, 2) + Math.pow(b2, 2));\n\n\t\tconst avgCp = (c1p + c2p) / 2;\n\n\t\tlet h1p = Math.rad2deg(Math.atan2(b1, a1p));\n\t\tif (h1p < 0) {\n\t\t\th1p = h1p + 360;\n\t\t}\n\n\t\tlet h2p = Math.rad2deg(Math.atan2(b2, a2p));\n\t\tif (h2p < 0) {\n\t\t\th2p = h2p + 360;\n\t\t}\n\n\t\tconst avghp = Math.abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;\n\n\t\tconst t = 1 - 0.17 * Math.cos(Math.deg2rad(avghp - 30)) + 0.24 * Math.cos(Math.deg2rad(2 * avghp)) + 0.32 * Math.cos(Math.deg2rad(3 * avghp + 6)) - 0.2 * Math.cos(Math.deg2rad(4 * avghp - 63));\n\n\t\tlet deltahp = h2p - h1p;\n\t\tif (Math.abs(deltahp) > 180) {\n\t\t\tif (h2p <= h1p) {\n\t\t\t\tdeltahp += 360;\n\t\t\t} else {\n\t\t\t\tdeltahp -= 360;\n\t\t\t}\n\t\t}\n\n\t\tconst deltalp = l2 - l1;\n\t\tconst deltacp = c2p - c1p;\n\n\t\tdeltahp = 2 * Math.sqrt(c1p * c2p) * Math.sin(Math.deg2rad(deltahp) / 2);\n\n\t\tconst sl = 1 + ((0.015 * Math.pow(avgL - 50, 2)) / Math.sqrt(20 + Math.pow(avgL - 50, 2)));\n\t\tconst sc = 1 + 0.045 * avgCp;\n\t\tconst sh = 1 + 0.015 * avgCp * t;\n\n\t\tconst deltaro = 30 * Math.exp(-(Math.pow((avghp - 275) / 25, 2)));\n\t\tconst rc = 2 * Math.sqrt(Math.pow(avgCp, 7) / (Math.pow(avgCp, 7) + Math.pow(25, 7)));\n\t\tconst rt = -rc * Math.sin(2 * Math.deg2rad(deltaro));\n\n\t\tconst kl = 1;\n\t\tconst kc = 1;\n\t\tconst kh = 1;\n\n\t\tconst deltaE = Math.sqrt(Math.pow(deltalp / (kl * sl), 2) + Math.pow(deltacp / (kc * sc), 2) + Math.pow(deltahp / (kh * sh), 2) + rt * (deltacp / (kc * sc)) * (deltahp / (kh * sh)));\n\n\t\treturn deltaE;\n\t}\n\t/**\n\t * Get darker colour of the given colour\n\t * @param {[Number]} r     Red value from 0 to 255\n\t * @param {[Number]} g     Green value from 0 to 255\n\t * @param {[Number]} b     Blue value from 0 to 255\n\t */\n\tstatic getDarkerColour(r, g, b, a = 1, darkenPercentage = 0.05) {\n\t\tlet [l1, a1, b1] = Colour.rgba2lab(r, g, b, a);\n\t\tl1 -= l1 * darkenPercentage;\n\t\tif (l1 < 0) {\n\t\t\tl1 = 0;\n\t\t}\n\t\treturn Colour.lab2rgba(l1, a1, b1); // [R, G, B, A]\n\t}\n\t/**\n\t * Get brighter colour of the given colour\n\t * @param {[Number]} r     Red value from 0 to 255\n\t * @param {[Number]} g     Green value from 0 to 255\n\t * @param {[Number]} b     Blue value from 0 to 255\n\t */\n\tstatic getBrighterColour(r, g, b, a = 1, brighterPercentage = 0.05) {\n\t\tlet [l1, a1, b1] = Colour.rgba2lab(r, g, b, a);\n\t\tl1 += l1 * brighterPercentage;\n\t\tif (l1 > 100) {\n\t\t\tl1 = 100;\n\t\t}\n\t\treturn Colour.lab2rgba(l1, a1, b1); // [R, G, B, A]\n\t}\n}\n","import { ModeType } from '../constants';\n\nexport function modeDescription(mode: ModeType): string {\n    return {\n        intensity: 'Intensity (faster)',\n        saliency: 'Saliency (slower)',\n    }[mode];\n}\n\nexport function extractRunsByCutoff(\n    width: number,\n    height: number,\n    passesCutoff: (row: number, column: number) => boolean\n) {\n    // compute 'runs' of pixels > cutoff in the image rows to use as line widths\n    const runs: number[][] = [];\n    for (let row = 0; row < height; row++) {\n        for (let col = 0; col < width; col++) {\n            const i = row * width + col;\n            if (passesCutoff(row, col)) {\n                // Decide whether we're still on the last run, or make a new one\n                if (\n                    runs.length > 0 &&\n                    col > 0 &&\n                    runs[runs.length - 1][runs[runs.length - 1].length - 1] === i - 1\n                ) {\n                    runs[runs.length - 1].push(i);\n                } else {\n                    runs.push([i]);\n                }\n            }\n        }\n    }\n    return runs;\n}\n","import { parse } from '@babel/parser';\nimport { CanvasType, ModeType, SIZE_BUFFER_RATIO } from '../constants';\nimport { WhitespaceMarkerGenerator } from '../generator';\nimport { parseTokens, minCodeSize, reshape } from '../reshape';\nimport { findRegionsByIntensity } from './intensity';\nimport { findRegionsBySaliency } from './saliency';\n\nexport async function drawCodeCommon(\n    code: string,\n    imageFileUri: string,\n    mode: ModeType,\n    cutoff: number,\n    invert: boolean,\n    loadImageToCanvas: (\n        imageFileUri: string,\n        targetSize: number\n    ) => Promise<{ canvas: CanvasType; ctx: CanvasRenderingContext2D }>\n): Promise<string> {\n    const genCode = new WhitespaceMarkerGenerator(parse(code)).generate().code;\n    const tokens = parseTokens(genCode);\n    if (invert) {\n        cutoff = 1 - cutoff;\n    }\n    // maybe have user click which areas to fill in?\n    const targetSize = (minCodeSize(tokens) * SIZE_BUFFER_RATIO) / cutoff;\n    const { canvas, ctx } = await loadImageToCanvas(imageFileUri, targetSize);\n    // TODO make these a web worker to avoid blocking\n    const runs =\n        mode === 'saliency'\n            ? findRegionsBySaliency(canvas, ctx, cutoff, invert)\n            : findRegionsByIntensity(canvas, ctx, cutoff, invert);\n    // Run reshape according to those runs of pixels\n    const shapeFn = (i: number) =>\n        i < runs.length ? runs[i].length : Number.MAX_SAFE_INTEGER;\n    const codeSegments = reshape(tokens, shapeFn);\n    if (codeSegments.length > runs.length + 1) {\n        // should never be reached!\n        throw new Error(\n            `Unexpected segment length of ${codeSegments.length} from ${runs.length} runs`\n        );\n    }\n    // If there are more runs than segments, populate remainder with empty spaces\n    while (codeSegments.length < runs.length) {\n        const nextRunLength = runs[codeSegments.length].length;\n        if (nextRunLength > 5) {\n            // longer runs can be filled in to more closely match appearance\n            codeSegments.push(`/*${'o'.repeat(nextRunLength - 4)}*/`);\n        } else {\n            codeSegments.push(' '.repeat(nextRunLength));\n        }\n    }\n    let result = '';\n    let runIndex = 0;\n    for (let row = 0; row < canvas.height; row++) {\n        for (let col = 0; col < canvas.width; col++) {\n            const i = row * canvas.width + col;\n            if (runIndex < runs.length && i >= runs[runIndex][0]) {\n                result += codeSegments[runIndex] + ' ';\n                col += codeSegments[runIndex].length;\n                runIndex++;\n            } else {\n                // for multiple runs in the same line, put spaces between them\n                result += ' ';\n            }\n        }\n        result += '\\n';\n    }\n    for (let i = runIndex; i < codeSegments.length; i++) {\n        result += `\\n${codeSegments[i]}`;\n    }\n    return result;\n}\n\n// improvement idea: https://dahtah.github.io/imager/foreground_background.html#k-nearest-neighbour-approach\n","import { createCanvas, loadImage } from 'node-canvas';\nimport { DEFAULT_HEIGHT_WIDTH_RATIO, ModeType } from '../constants';\nimport { drawCodeCommon } from './drawCode';\n\nasync function loadImageToCanvas(imageFilePath: string, targetSize: number) {\n    const image = await loadImage(imageFilePath);\n    // Find the ratio to get from source dimensions to target size\n    // math check: e.g. target = 16, s.w = s.h = 2, then ratio = 2 as expected\n    const ratio = Math.sqrt(targetSize / (image.width * image.height));\n    const targetWidth = Math.round(\n        image.width * ratio * Math.sqrt(DEFAULT_HEIGHT_WIDTH_RATIO)\n    );\n    const targetHeight = Math.round(\n        (image.height * ratio) / Math.sqrt(DEFAULT_HEIGHT_WIDTH_RATIO)\n    );\n\n    const target = createCanvas(targetWidth, targetHeight);\n    const ctx = target.getContext('2d')!;\n    ctx.drawImage(image, 0, 0, target.width, target.height);\n    return { canvas: target, ctx: ctx as CanvasRenderingContext2D };\n}\n\nexport async function drawCode(\n    code: string,\n    imageFileUri: string,\n    mode: ModeType,\n    cutoff: number,\n    invert: boolean\n): Promise<string> {\n    return drawCodeCommon(code, imageFileUri, mode, cutoff, invert, loadImageToCanvas);\n}\n","import { CanvasType, INTENSITY_RANGE } from '../constants';\nimport { extractRunsByCutoff } from './common';\n\n// Return consecutive indices (row * width + col) where code should be placed\n// How does it work?\n// First I convert every pixel to an intensity (for now just r + g + b)\n// Then I make a histogram and find the cutoff value above which there are image size * INTENSITY_CUTOFF pixels\n\n// Finally go through the image again and mark consecutive runs of such pixels\nexport function findRegionsByIntensity(\n    canvas: CanvasType,\n    ctx: CanvasRenderingContext2D,\n    cutoffRatio: number,\n    invert: boolean\n): number[][] {\n    // Build an intensity histogram so we can find the value that hits cutoff\n    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const histogram: number[] = new Array(INTENSITY_RANGE).fill(0);\n    for (let i = 0; i < data.data.length; i += 4) {\n        const [r, g, b, a] = data.data.slice(i, i + 4);\n        const intensity = Math.round((a / 255) * (r + g + b));\n        histogram[intensity]++;\n    }\n\n    // Find the cutoff value by looking at histogram\n    const cutoff = data.width * data.height * cutoffRatio;\n    let accum = 0;\n    let cutoffValue = histogram.length - 1;\n    if (invert) {\n        histogram.reverse();\n    }\n    while (accum < cutoff && cutoffValue > 0) {\n        accum += histogram[cutoffValue];\n        cutoffValue--;\n    }\n    if (invert) {\n        cutoffValue = histogram.length - 1 - cutoffValue;\n    }\n    return extractRunsByCutoff(data.width, data.height, (row, col) => {\n        const i = row * data.width + col;\n        const [r, g, b, a] = data.data.slice(i * 4, (i + 1) * 4);\n        const intensity = Math.round((a / 255) * (r + g + b));\n        return invert ? intensity <= cutoffValue : intensity >= cutoffValue;\n    });\n}\n","import { SALIENCY_BUCKETS, CanvasType } from '../constants';\nimport { extractRunsByCutoff } from './common';\n\nimport { Colour } from '../vendor/IsThisColourSimilar/Colour';\nimport LRUCache from 'lru-cache';\n\n// Retain the top-n histogram buckets to reach THRESHOLD coverage of the picture.\n// Fold anything that doesn't reach the threshold to the nearest bucket, by manhattan distance.\nconst HISTOGRAM_THRESHOLD = 0.95;\n\nconst bucketSize = 256 / SALIENCY_BUCKETS;\nconst toBucket = (value: number) => Math.floor(value / bucketSize);\nconst colorToIndex = (r: number, g: number, b: number) =>\n    toBucket(r) * SALIENCY_BUCKETS * SALIENCY_BUCKETS +\n    toBucket(g) * SALIENCY_BUCKETS +\n    toBucket(b);\n\nconst indexToColor: [number, number, number][] = new Array(\n    Math.pow(SALIENCY_BUCKETS, 3)\n)\n    .fill(0)\n    .map((_, idx) => {\n        const rIndex = Math.floor(idx / (SALIENCY_BUCKETS * SALIENCY_BUCKETS));\n        const gIndex = Math.floor((idx - rIndex) / SALIENCY_BUCKETS);\n        const bIndex = idx - rIndex - gIndex;\n        return [\n            (rIndex + 0.5) * bucketSize,\n            (gIndex + 0.5) * bucketSize,\n            (bIndex + 0.5) * bucketSize,\n        ];\n    });\n\nconst rgbCache = new LRUCache({ max: 2 * Math.pow(SALIENCY_BUCKETS, 3) });\n\nfunction rgb2lab(r: number, g: number, b: number): number[] {\n    const key = [r, g, b].join(' ');\n    const res = rgbCache.get(key) as number[];\n    if (res != null) {\n        return res;\n    } else {\n        // @ts-ignore no types provided\n        const lab = Colour.rgba2lab(r, g, b);\n        rgbCache.set(key, lab);\n        return lab;\n    }\n}\n\nconst diff = (\n    r1: number,\n    g1: number,\n    blu1: number,\n    r2: number,\n    g2: number,\n    blu2: number\n) => {\n    const [l1, a1, b1] = rgb2lab(r1, g1, blu1);\n    const [l2, a2, b2] = rgb2lab(r2, g2, blu2);\n    // @ts-ignore no types provided\n    return Colour.deltaE00(l1, a1, b1, l2, a2, b2);\n};\n\nclass CompressedHistogram {\n    compressed: { originalIndex: number; count: number }[] = [];\n    // maps original index to compressed index (many-to-one mapping)\n    originalToCompressedMap: Map<number, number> = new Map();\n\n    constructor(histogram: number[]) {\n        const total = histogram.reduce((prev, cur) => prev + cur, 0);\n        const target = Math.round(total * HISTOGRAM_THRESHOLD);\n        const sorted = histogram\n            .map((v, idx) => ({ v, idx }))\n            .sort((a, b) => b.v - a.v);\n        let i, accum;\n        for (i = 0, accum = 0; i < sorted.length && accum < target; i++) {\n            const { v, idx } = sorted[i];\n            accum += v;\n            this.compressed.push({ originalIndex: idx, count: v });\n            this.originalToCompressedMap.set(idx, this.compressed.length - 1);\n        }\n        for (; i < sorted.length; i++) {\n            const { v, idx } = sorted[i];\n            // add the remaining values to their closest neighbors in the histogram\n            const [r1, g1, blu1] = indexToColor[idx];\n            const [l1, a1, b1] = rgb2lab(r1, g1, blu1);\n            let smallestDelta = Number.MAX_SAFE_INTEGER;\n            let smallestDeltaIdx = 0;\n            // find the closest color by perceptual difference\n            for (const { delta, idx } of this.compressed.map(\n                ({ originalIndex }, idx) => {\n                    const [r2, g2, blu2] = indexToColor[originalIndex];\n                    const [l2, a2, b2] = rgb2lab(r2, g2, blu2);\n                    // @ts-ignore no types provided\n                    return { delta: Colour.deltaE00(l1, a1, b1, l2, a2, b2), idx };\n                }\n            )) {\n                if (delta < smallestDelta) {\n                    smallestDelta = delta;\n                    smallestDeltaIdx = idx;\n                }\n            }\n            this.compressed[smallestDeltaIdx].count += v;\n            this.originalToCompressedMap.set(idx, smallestDeltaIdx);\n        }\n    }\n\n    /**\n     * Given color r, g, b, compute its saliency from the histogram.\n     * Saliency of a pixel is sum of its color distance with all other pixels\n     * instead of comparing every pair of pixels, we take distance against each histogram bucket,\n     * weighted by the size of its set\n     */\n    saliency(r: number, g: number, b: number) {\n        const pixelIndex = colorToIndex(r, g, b);\n        const compressedPixelIndex = this.originalToCompressedMap.get(pixelIndex)!;\n        return this.compressed.reduce((prev, cur, idx) => {\n            if (idx === compressedPixelIndex) {\n                return prev;\n            } else {\n                const [rh, gh, bh] = indexToColor[cur.originalIndex];\n                return prev + cur.count * diff(r, g, b, rh, gh, bh);\n            }\n        }, 0);\n    }\n}\n\n// Uses global perceptual contrast to detect salient regions,\n// implementation of the algorithm in the below paper:\n// M.-M. Cheng et al., \"Global Contrast based Salient Region Detection\", in IEEE CVPR, 2011\n// https://mmcheng.net/mftp/Papers/SaliencyTPAMI.pdf\nexport function findRegionsBySaliency(\n    canvas: CanvasType,\n    ctx: CanvasRenderingContext2D,\n    cutoffRatio: number,\n    invert: boolean\n) {\n    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    // cheng method quantizes 0, 255 range into 12 buckets for each of r,g,b\n    const colorHistogram: number[] = new Array(Math.pow(SALIENCY_BUCKETS, 3)).fill(0);\n    // group each pixel into histogram based by rgb value\n    for (let i = 0; i < data.data.length; i += 4) {\n        const [r, g, b] = data.data.slice(i, i + 3);\n        colorHistogram[colorToIndex(r, g, b)]++;\n    }\n    const histogram = new CompressedHistogram(colorHistogram);\n    const perPixelSaliency: number[] = new Array(canvas.width * canvas.height);\n    for (let i = 0; i < data.data.length; i += 4) {\n        const [r, g, b] = data.data.slice(i, i + 3);\n        perPixelSaliency[i / 4] = histogram.saliency(r, g, b);\n    }\n    const sortedPixels = perPixelSaliency\n        .concat()\n        .sort((a, b) => (invert ? a - b : b - a));\n    const cutoffValue = sortedPixels[Math.round(cutoffRatio * sortedPixels.length)];\n\n    return extractRunsByCutoff(data.width, data.height, (row, col) => {\n        const i = row * data.width + col;\n        return invert\n            ? perPixelSaliency[i] <= cutoffValue\n            : perPixelSaliency[i] >= cutoffValue;\n    });\n}\n"],"mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;AC3VA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;;AAOA;AACA;AAAA;AACA;AACA;A;;;;;;;;;;;;;;;AChCA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;AC9CA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAJA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;A","sourceRoot":""}