{"version":3,"file":"algos_entry-dom_ts.bundle.js","sources":["webpack:///./vendor/IsThisColourSimilar/Colour.js","webpack:///./algos/drawCode.ts","webpack:///./algos/entry-dom.ts","webpack:///./algos/intensity.ts","webpack:///./algos/saliency.ts","webpack:///./generator.ts","webpack:///./reshape.ts"],"sourcesContent":["/**\n * Colour class\n * Represet the colour object and it's different types (HEX, RGBA, XYZ, LAB)\n * This class have the ability to do the following\n * 1. Convert HEX to RGBA\n * 2. Convert RGB to XYZ\n * 3. Convert XYZ to LAB\n * 4. Calculate Delta E00 between two LAB colour (Main purpose)\n * @author Ahmed Moussa <moussa.ahmed95@gmail.com>\n * @version 2.0\n */\n export class Colour {\n\t/**\n\t * Convert HEX to LAB\n\t * @param {[string]} hex hex colour value desired to be converted to LAB\n\t */\n\tstatic hex2lab(hex) {\n\t\tconst [r, g, b, a] = Colour.hex2rgba(hex);\n\t\tconst [x, y, z] = Colour.rgb2xyz(r, g, b, a);\n\t\treturn Colour.xyz2lab(x, y, z); // [l, a, b]\n\t}\n\t/**\n\t * Convert RGBA to LAB\n\t * @param {[Number]} r     Red value from 0 to 255\n\t * @param {[Number]} g     Green value from 0 to 255\n\t * @param {[Number]} b     Blue value from 0 to 255\n\t */\n\tstatic rgba2lab(r, g, b, a = 1) {\n\t\tconst [x, y, z] = Colour.rgb2xyz(r, g, b, a);\n\t\treturn Colour.xyz2lab(x, y, z); // [l, a, b]\n\t}\n\t/**\n\t * Convert LAB to RGBA\n\t * @param {[Number]} l\n\t * @param {[Number]} a\n\t * @param {[Number]} b \n\t */\n\tstatic lab2rgba(l, a, b) {\n\t\tconst [x, y, z] = Colour.lab2xyz(l, a, b);\n\t\treturn Colour.xyz2rgba(x, y, z); // [r, g, b, a]\n\t}\n\t/**\n\t * Convert HEX to RGBA\n\t * @param {[string]} hex hex colour value desired to be converted to RGBA\n\t */\n\tstatic hex2rgba(hex) {\n\t\tlet c;\n\t\tif (hex.charAt(0) === \"#\") {\n\t\t\tc = hex.substring(1).split('');\n\t\t}\n\t\tif (c.length > 6 || c.length < 3) {\n\t\t\tthrow new Error(`HEX colour must be 3 or 6 values. You provided it ${c.length}`);\n\t\t}\n\t\tif (c.length === 3) {\n\t\t\tc = [c[0], c[0], c[1], c[1], c[2], c[2]];\n\t\t}\n\t\tc = \"0x\" + c.join(\"\");\n\t\tlet r = (c >> 16) & 255;\n\t\tlet g = (c >> 8) & 255;\n\t\tlet b = c & 255;\n\t\tlet a = 1;\n\t\treturn [r, g, b, a];\n\t}\n\t/**\n\t * Convert RGB to XYZ\n\t * @param {[Number]} r     Red value from 0 to 255\n\t * @param {[Number]} g     Green value from 0 to 255\n\t * @param {[Number]} b     Blue value from 0 to 255\n\t * @param {Number} [a=1]   Obacity value from 0 to 1 with a default value of 1 if not sent\n\t */\n\tstatic rgb2xyz(r, g, b, a = 1) {\n\t\tif (r > 255) {\n\t\t\t// console.warn(\"Red value was higher than 255. It has been set to 255.\");\n\t\t\tr = 255;\n\t\t} else if (r < 0) {\n\t\t\t// console.warn(\"Red value was smaller than 0. It has been set to 0.\");\n\t\t\tr = 0;\n\t\t}\n\t\tif (g > 255) {\n\t\t\t// console.warn(\"Green value was higher than 255. It has been set to 255.\");\n\t\t\tg = 255;\n\t\t} else if (g < 0) {\n\t\t\t// console.warn(\"Green value was smaller than 0. It has been set to 0.\");\n\t\t\tg = 0;\n\t\t}\n\t\tif (b > 255) {\n\t\t\t// console.warn(\"Blue value was higher than 255. It has been set to 255.\");\n\t\t\tb = 255;\n\t\t} else if (b < 0) {\n\t\t\t// console.warn(\"Blue value was smaller than 0. It has been set to 0.\");\n\t\t\tb = 0;\n\t\t}\n\t\tif (a > 1) {\n\t\t\t// console.warn(\"Obacity value was higher than 1. It has been set to 1.\");\n\t\t\ta = 1;\n\t\t} else if (a < 0) {\n\t\t\t// console.warn(\"Obacity value was smaller than 0. It has been set to 0.\");\n\t\t\ta = 0;\n\t\t}\n\t\tr = r / 255;\n\t\tg = g / 255;\n\t\tb = b / 255;\n\t\t// step 1\n\t\tif (r > 0.04045) {\n\t\t\tr = Math.pow(((r + 0.055) / 1.055), 2.4);\n\t\t} else {\n\t\t\tr = r / 12.92;\n\t\t}\n\t\tif (g > 0.04045) {\n\t\t\tg = Math.pow(((g + 0.055) / 1.055), 2.4);\n\t\t} else {\n\t\t\tg = g / 12.92;\n\t\t}\n\t\tif (b > 0.04045) {\n\t\t\tb = Math.pow(((b + 0.055) / 1.055), 2.4);\n\t\t} else {\n\t\t\tb = b / 12.92;\n\t\t}\n\t\t// step 2\n\t\tr = r * 100;\n\t\tg = g * 100;\n\t\tb = b * 100;\n\t\t// step 3\n\t\tconst x = (r * 0.4124564) + (g * 0.3575761) + (b * 0.1804375);\n\t\tconst y = (r * 0.2126729) + (g * 0.7151522) + (b * 0.0721750);\n\t\tconst z = (r * 0.0193339) + (g * 0.1191920) + (b * 0.9503041);\n\t\treturn [x, y, z];\n\t}\n\t/**\n\t * Convert XYZ to RGBA\n\t * @param {[Number]} x\n\t * @param {[Number]} y\n\t * @param {[Number]} z\n\t */\n\tstatic xyz2rgba(x, y, z) {\n\t\tlet varX = x / 100;\n\t\tlet varY = y / 100;\n\t\tlet varZ = z / 100;\n\n\t\tlet varR = (varX *  3.2404542) + (varY * -1.5371385) + (varZ * -0.4985314);\n\t\tlet varG = (varX * -0.9692660) + (varY *  1.8760108) + (varZ * 0.0415560);\n\t\tlet varB = (varX *  0.0556434) + (varY * -0.2040259) + (varZ * 1.0572252);\n\n\t\tif ( varR > 0.0031308 ) {\n\t\t\tvarR = 1.055 * Math.pow(varR, (1 / 2.4) ) - 0.055;\n\t\t} else {\n\t\t\tvarR = 12.92 * varR;\n\t\t}\n\t\tif ( varG > 0.0031308 ) {\n\t\t\tvarG = 1.055 * Math.pow(varG, (1 / 2.4) ) - 0.055;\n\t\t} else {\n\t\t\tvarG = 12.92 * varG;\n\t\t}\n\t\tif ( varB > 0.0031308 ) {\n\t\t\tvarB = 1.055 * Math.pow(varB, (1 / 2.4) ) - 0.055;\n\t\t} else {\n\t\t\tvarB = 12.92 * varB;\n\t\t}\n\n\t\tlet r = Math.round(varR * 255);\n\t\tlet g = Math.round(varG * 255);\n\t\tlet b = Math.round(varB * 255);\n\n\t\treturn [r, g, b, 1];\n\t}\n\t/**\n\t * Convert XYZ to LAB\n\t * @param {[Number]} x Value\n\t * @param {[Number]} y Value\n\t * @param {[Number]} z Value\n\t */\n\tstatic xyz2lab(x, y, z) {\n\t\t// using 10o Observer (CIE 1964)\n\t\t// CIE10_D65 = {94.811f, 100f, 107.304f} => Daylight\n\t\tconst referenceX = 94.811;\n\t\tconst referenceY = 100;\n\t\tconst referenceZ = 107.304;\n\t\t// step 1\n\t\tx = x / referenceX;\n\t\ty = y / referenceY;\n\t\tz = z / referenceZ;\n\t\t// step 2\n\t\tif (x > 0.008856) {\n\t\t\tx = Math.pow(x, (1 / 3));\n\t\t} else {\n\t\t\tx = (7.787 * x) + (16 / 116);\n\t\t}\n\t\tif (y > 0.008856) {\n\t\t\ty = Math.pow(y, (1 / 3));\n\t\t} else {\n\t\t\ty = (7.787 * y) + (16 / 116);\n\t\t}\n\t\tif (z > 0.008856) {\n\t\t\tz = Math.pow(z, (1 / 3));\n\t\t} else {\n\t\t\tz = (7.787 * z) + (16 / 116);\n\t\t}\n\t\t// step 3\n\t\tconst l = (116 * y) - 16;\n\t\tconst a = 500 * (x - y);\n\t\tconst b = 200 * (y - z);\n\t\treturn [l, a, b];\n\t}\n\t/**\n\t * Convert LAB to XYZ\n\t * @param {[Number]} l\n\t * @param {[Number]} a\n\t * @param {[Number]} b\n\t */\n\tstatic lab2xyz(l, a, b) {\n\t\t// using 10o Observer (CIE 1964)\n\t\t// CIE10_D65 = {94.811f, 100f, 107.304f} => Daylight\n\t\tconst referenceX = 94.811;\n\t\tconst referenceY = 100;\n\t\tconst referenceZ = 107.304;\n\n\t\tlet varY = ( l + 16 ) / 116;\n\t\tlet varX = a / 500 + varY;\n\t\tlet varZ = varY - b / 200;\n\n\t\tif ( Math.pow(varY, 3)  > 0.008856 ) {\n\t\t\tvarY = Math.pow(varY, 3);\n\t\t} else {\n\t\t\tvarY = ( varY - 16 / 116 ) / 7.787;\n\t\t}\n\t\tif ( Math.pow(varX, 3)  > 0.008856 ) {\n\t\t\tvarX = Math.pow(varX, 3);\n\t\t} else {\n\t\t\tvarX = ( varX - 16 / 116 ) / 7.787;\n\t\t}\n\t\tif ( Math.pow(varZ, 3)  > 0.008856 ) {\n\t\t\tvarZ = Math.pow(varZ, 3);\n\t\t} else {\n\t\t\tvarZ = ( varZ - 16 / 116 ) / 7.787;\n\t\t}\n\n\t\tlet x = varX * referenceX;\n\t\tlet y = varY * referenceY;\n\t\tlet z = varZ * referenceZ;\n\n\t\treturn [x, y, z];\n\t}\n\t/**\n\t * The difference between two given colours with respect to the human eye\n\t * @param {[type]} l1 Colour 1\n\t * @param {[type]} a1 Colour 1\n\t * @param {[type]} b1 Colour 1\n\t * @param {[type]} l2 Colour 2\n\t * @param {[type]} a2 Colour 2\n\t * @param {[type]} b2 Colour 2\n\t */\n\tstatic deltaE00(l1, a1, b1, l2, a2, b2) {\n\t\t// Utility functions added to Math Object\n\t\tMath.rad2deg = function(rad) {\n\t\t\treturn 360 * rad / (2 * Math.PI);\n\t\t};\n\t\tMath.deg2rad = function(deg) {\n\t\t\treturn (2 * Math.PI * deg) / 360;\n\t\t};\n\t\t// Start Equation\n\t\t// Equation exist on the following URL http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html\n\t\tconst avgL = (l1 + l2) / 2;\n\t\tconst c1 = Math.sqrt(Math.pow(a1, 2) + Math.pow(b1, 2));\n\t\tconst c2 = Math.sqrt(Math.pow(a2, 2) + Math.pow(b2, 2));\n\t\tconst avgC = (c1 + c2) / 2;\n\t\tconst g = (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7)))) / 2;\n\n\t\tconst a1p = a1 * (1 + g);\n\t\tconst a2p = a2 * (1 + g);\n\n\t\tconst c1p = Math.sqrt(Math.pow(a1p, 2) + Math.pow(b1, 2));\n\t\tconst c2p = Math.sqrt(Math.pow(a2p, 2) + Math.pow(b2, 2));\n\n\t\tconst avgCp = (c1p + c2p) / 2;\n\n\t\tlet h1p = Math.rad2deg(Math.atan2(b1, a1p));\n\t\tif (h1p < 0) {\n\t\t\th1p = h1p + 360;\n\t\t}\n\n\t\tlet h2p = Math.rad2deg(Math.atan2(b2, a2p));\n\t\tif (h2p < 0) {\n\t\t\th2p = h2p + 360;\n\t\t}\n\n\t\tconst avghp = Math.abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;\n\n\t\tconst t = 1 - 0.17 * Math.cos(Math.deg2rad(avghp - 30)) + 0.24 * Math.cos(Math.deg2rad(2 * avghp)) + 0.32 * Math.cos(Math.deg2rad(3 * avghp + 6)) - 0.2 * Math.cos(Math.deg2rad(4 * avghp - 63));\n\n\t\tlet deltahp = h2p - h1p;\n\t\tif (Math.abs(deltahp) > 180) {\n\t\t\tif (h2p <= h1p) {\n\t\t\t\tdeltahp += 360;\n\t\t\t} else {\n\t\t\t\tdeltahp -= 360;\n\t\t\t}\n\t\t}\n\n\t\tconst deltalp = l2 - l1;\n\t\tconst deltacp = c2p - c1p;\n\n\t\tdeltahp = 2 * Math.sqrt(c1p * c2p) * Math.sin(Math.deg2rad(deltahp) / 2);\n\n\t\tconst sl = 1 + ((0.015 * Math.pow(avgL - 50, 2)) / Math.sqrt(20 + Math.pow(avgL - 50, 2)));\n\t\tconst sc = 1 + 0.045 * avgCp;\n\t\tconst sh = 1 + 0.015 * avgCp * t;\n\n\t\tconst deltaro = 30 * Math.exp(-(Math.pow((avghp - 275) / 25, 2)));\n\t\tconst rc = 2 * Math.sqrt(Math.pow(avgCp, 7) / (Math.pow(avgCp, 7) + Math.pow(25, 7)));\n\t\tconst rt = -rc * Math.sin(2 * Math.deg2rad(deltaro));\n\n\t\tconst kl = 1;\n\t\tconst kc = 1;\n\t\tconst kh = 1;\n\n\t\tconst deltaE = Math.sqrt(Math.pow(deltalp / (kl * sl), 2) + Math.pow(deltacp / (kc * sc), 2) + Math.pow(deltahp / (kh * sh), 2) + rt * (deltacp / (kc * sc)) * (deltahp / (kh * sh)));\n\n\t\treturn deltaE;\n\t}\n\t/**\n\t * Get darker colour of the given colour\n\t * @param {[Number]} r     Red value from 0 to 255\n\t * @param {[Number]} g     Green value from 0 to 255\n\t * @param {[Number]} b     Blue value from 0 to 255\n\t */\n\tstatic getDarkerColour(r, g, b, a = 1, darkenPercentage = 0.05) {\n\t\tlet [l1, a1, b1] = Colour.rgba2lab(r, g, b, a);\n\t\tl1 -= l1 * darkenPercentage;\n\t\tif (l1 < 0) {\n\t\t\tl1 = 0;\n\t\t}\n\t\treturn Colour.lab2rgba(l1, a1, b1); // [R, G, B, A]\n\t}\n\t/**\n\t * Get brighter colour of the given colour\n\t * @param {[Number]} r     Red value from 0 to 255\n\t * @param {[Number]} g     Green value from 0 to 255\n\t * @param {[Number]} b     Blue value from 0 to 255\n\t */\n\tstatic getBrighterColour(r, g, b, a = 1, brighterPercentage = 0.05) {\n\t\tlet [l1, a1, b1] = Colour.rgba2lab(r, g, b, a);\n\t\tl1 += l1 * brighterPercentage;\n\t\tif (l1 > 100) {\n\t\t\tl1 = 100;\n\t\t}\n\t\treturn Colour.lab2rgba(l1, a1, b1); // [R, G, B, A]\n\t}\n}\n","import { parse } from '@babel/parser';\nimport { CanvasType, ModeType, SIZE_BUFFER_RATIO } from '../constants';\nimport { WhitespaceMarkerGenerator } from '../generator';\nimport { parseTokens, minCodeSize, reshape } from '../reshape';\nimport { findRegionsByIntensity } from './intensity';\nimport { findRegionsBySaliency } from './saliency';\n\nexport async function drawCodeCommon(\n    code: string,\n    imageFileUri: string,\n    mode: ModeType,\n    cutoff: number,\n    invert: boolean,\n    loadImageToCanvas: (\n        imageFileUri: string,\n        targetSize: number\n    ) => Promise<{ canvas: CanvasType; ctx: CanvasRenderingContext2D }>\n): Promise<string> {\n    const genCode = new WhitespaceMarkerGenerator(parse(code)).generate().code;\n    const tokens = parseTokens(genCode);\n    if (invert) {\n        cutoff = 1 - cutoff;\n    }\n    // maybe have user click which areas to fill in?\n    const targetSize = (minCodeSize(tokens) * SIZE_BUFFER_RATIO) / cutoff;\n    const { canvas, ctx } = await loadImageToCanvas(imageFileUri, targetSize);\n    // TODO make these a web worker to avoid blocking\n    const runs =\n        mode === 'saliency'\n            ? findRegionsBySaliency(canvas, ctx, cutoff, invert)\n            : findRegionsByIntensity(canvas, ctx, cutoff, invert);\n    // Run reshape according to those runs of pixels\n    const shapeFn = (i: number) =>\n        i < runs.length ? runs[i].length : Number.MAX_SAFE_INTEGER;\n    const codeSegments = reshape(tokens, shapeFn);\n    if (codeSegments.length > runs.length + 1) {\n        // should never be reached!\n        throw new Error(\n            `Unexpected segment length of ${codeSegments.length} from ${runs.length} runs`\n        );\n    }\n    // If there are more runs than segments, populate remainder with empty spaces\n    while (codeSegments.length < runs.length) {\n        const nextRunLength = runs[codeSegments.length].length;\n        if (nextRunLength > 5) {\n            // longer runs can be filled in to more closely match appearance\n            codeSegments.push(`/*${'o'.repeat(nextRunLength - 4)}*/`);\n        } else {\n            codeSegments.push(' '.repeat(nextRunLength));\n        }\n    }\n    let result = '';\n    let runIndex = 0;\n    for (let row = 0; row < canvas.height; row++) {\n        for (let col = 0; col < canvas.width; col++) {\n            const i = row * canvas.width + col;\n            if (runIndex < runs.length && i >= runs[runIndex][0]) {\n                result += codeSegments[runIndex] + ' ';\n                col += codeSegments[runIndex].length;\n                runIndex++;\n            } else {\n                // for multiple runs in the same line, put spaces between them\n                result += ' ';\n            }\n        }\n        result += '\\n';\n    }\n    for (let i = runIndex; i < codeSegments.length; i++) {\n        result += `\\n${codeSegments[i]}`;\n    }\n    return result;\n}\n\n// improvement idea: https://dahtah.github.io/imager/foreground_background.html#k-nearest-neighbour-approach\n","import { DEFAULT_HEIGHT_WIDTH_RATIO, ModeType } from '../constants';\nimport { drawCodeCommon } from './drawCode';\n\nconst pica = import('pica');\n\n// Load the given image uri to an invisible canvas and return the canvas and its 2d context\n// Also resize the picture to make its pixel count as close to targetSize as possible\nasync function loadImageToCanvas(imageFileUri: string, targetSize: number) {\n    // First load the image onto an invisible canvas\n    const source = document.createElement('canvas');\n    const ctx = source.getContext('2d')!;\n    await new Promise<void>((resolve, reject) => {\n        const handler = () => {\n            source.width = Math.floor(image.width);\n            source.height = Math.floor(image.height);\n            ctx.drawImage(image, 0, 0, source.width, source.height);\n            resolve();\n        };\n        const image = new Image();\n        image.onload = handler;\n        image.onerror = reject;\n        image.src = imageFileUri;\n    });\n    const target = document.createElement('canvas');\n    // Find the ratio to get from source dimensions to target size\n    // math check: e.g. target = 16, s.w = s.h = 2, then ratio = 2 as expected\n    const ratio = Math.sqrt(targetSize / (source.width * source.height));\n    target.width = Math.round(\n        source.width * ratio * Math.sqrt(DEFAULT_HEIGHT_WIDTH_RATIO)\n    );\n    target.height = Math.round(\n        (source.height * ratio) / Math.sqrt(DEFAULT_HEIGHT_WIDTH_RATIO)\n    );\n    const resizer = (await pica).default();\n    await resizer.resize(source, target);\n    return { canvas: target, ctx: target.getContext('2d')! };\n}\n\nexport async function drawCode(\n    code: string,\n    imageFileUri: string,\n    mode: ModeType,\n    cutoff: number,\n    invert: boolean\n): Promise<string> {\n    console.time('code shaping');\n    const result = await drawCodeCommon(\n        code,\n        imageFileUri,\n        mode,\n        cutoff,\n        invert,\n        loadImageToCanvas\n    );\n    console.timeEnd('code shaping');\n    return result;\n}\n\n// improvement idea: https://dahtah.github.io/imager/foreground_background.html#k-nearest-neighbour-approach\n","import { CanvasType, INTENSITY_RANGE } from '../constants';\nimport { extractRunsByCutoff } from './common';\n\n// Return consecutive indices (row * width + col) where code should be placed\n// How does it work?\n// First I convert every pixel to an intensity (for now just r + g + b)\n// Then I make a histogram and find the cutoff value above which there are image size * INTENSITY_CUTOFF pixels\n\n// Finally go through the image again and mark consecutive runs of such pixels\nexport function findRegionsByIntensity(\n    canvas: CanvasType,\n    ctx: CanvasRenderingContext2D,\n    cutoffRatio: number,\n    invert: boolean\n): number[][] {\n    // Build an intensity histogram so we can find the value that hits cutoff\n    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const histogram: number[] = new Array(INTENSITY_RANGE).fill(0);\n    for (let i = 0; i < data.data.length; i += 4) {\n        const [r, g, b, a] = data.data.slice(i, i + 4);\n        const intensity = Math.round((a / 255) * (r + g + b));\n        histogram[intensity]++;\n    }\n\n    // Find the cutoff value by looking at histogram\n    const cutoff = data.width * data.height * cutoffRatio;\n    let accum = 0;\n    let cutoffValue = histogram.length - 1;\n    if (invert) {\n        histogram.reverse();\n    }\n    while (accum < cutoff && cutoffValue > 0) {\n        accum += histogram[cutoffValue];\n        cutoffValue--;\n    }\n    if (invert) {\n        cutoffValue = histogram.length - 1 - cutoffValue;\n    }\n    return extractRunsByCutoff(data.width, data.height, (row, col) => {\n        const i = row * data.width + col;\n        const [r, g, b, a] = data.data.slice(i * 4, (i + 1) * 4);\n        const intensity = Math.round((a / 255) * (r + g + b));\n        return invert ? intensity <= cutoffValue : intensity >= cutoffValue;\n    });\n}\n","import { SALIENCY_BUCKETS, CanvasType } from '../constants';\nimport { extractRunsByCutoff } from './common';\n\nimport { Colour } from '../vendor/IsThisColourSimilar/Colour';\nimport LRUCache from 'lru-cache';\n\n// Retain the top-n histogram buckets to reach THRESHOLD coverage of the picture.\n// Fold anything that doesn't reach the threshold to the nearest bucket, by manhattan distance.\nconst HISTOGRAM_THRESHOLD = 0.95;\n\nconst bucketSize = 256 / SALIENCY_BUCKETS;\nconst toBucket = (value: number) => Math.floor(value / bucketSize);\nconst colorToIndex = (r: number, g: number, b: number) =>\n    toBucket(r) * SALIENCY_BUCKETS * SALIENCY_BUCKETS +\n    toBucket(g) * SALIENCY_BUCKETS +\n    toBucket(b);\n\nconst indexToColor: [number, number, number][] = new Array(\n    Math.pow(SALIENCY_BUCKETS, 3)\n)\n    .fill(0)\n    .map((_, idx) => {\n        const rIndex = Math.floor(idx / (SALIENCY_BUCKETS * SALIENCY_BUCKETS));\n        const gIndex = Math.floor((idx - rIndex) / SALIENCY_BUCKETS);\n        const bIndex = idx - rIndex - gIndex;\n        return [\n            (rIndex + 0.5) * bucketSize,\n            (gIndex + 0.5) * bucketSize,\n            (bIndex + 0.5) * bucketSize,\n        ];\n    });\n\nconst rgbCache = new LRUCache({ max: 2 * Math.pow(SALIENCY_BUCKETS, 3) });\n\nfunction rgb2lab(r: number, g: number, b: number): number[] {\n    const key = [r, g, b].join(' ');\n    const res = rgbCache.get(key) as number[];\n    if (res != null) {\n        return res;\n    } else {\n        // @ts-ignore no types provided\n        const lab = Colour.rgba2lab(r, g, b);\n        rgbCache.set(key, lab);\n        return lab;\n    }\n}\n\nconst diff = (\n    r1: number,\n    g1: number,\n    blu1: number,\n    r2: number,\n    g2: number,\n    blu2: number\n) => {\n    const [l1, a1, b1] = rgb2lab(r1, g1, blu1);\n    const [l2, a2, b2] = rgb2lab(r2, g2, blu2);\n    // @ts-ignore no types provided\n    return Colour.deltaE00(l1, a1, b1, l2, a2, b2);\n};\n\nclass CompressedHistogram {\n    compressed: { originalIndex: number; count: number }[] = [];\n    // maps original index to compressed index (many-to-one mapping)\n    originalToCompressedMap: Map<number, number> = new Map();\n\n    constructor(histogram: number[]) {\n        const total = histogram.reduce((prev, cur) => prev + cur, 0);\n        const target = Math.round(total * HISTOGRAM_THRESHOLD);\n        const sorted = histogram\n            .map((v, idx) => ({ v, idx }))\n            .sort((a, b) => b.v - a.v);\n        let i, accum;\n        for (i = 0, accum = 0; i < sorted.length && accum < target; i++) {\n            const { v, idx } = sorted[i];\n            accum += v;\n            this.compressed.push({ originalIndex: idx, count: v });\n            this.originalToCompressedMap.set(idx, this.compressed.length - 1);\n        }\n        for (; i < sorted.length; i++) {\n            const { v, idx } = sorted[i];\n            // add the remaining values to their closest neighbors in the histogram\n            const [r1, g1, blu1] = indexToColor[idx];\n            const [l1, a1, b1] = rgb2lab(r1, g1, blu1);\n            let smallestDelta = Number.MAX_SAFE_INTEGER;\n            let smallestDeltaIdx = 0;\n            // find the closest color by perceptual difference\n            for (const { delta, idx } of this.compressed.map(\n                ({ originalIndex }, idx) => {\n                    const [r2, g2, blu2] = indexToColor[originalIndex];\n                    const [l2, a2, b2] = rgb2lab(r2, g2, blu2);\n                    // @ts-ignore no types provided\n                    return { delta: Colour.deltaE00(l1, a1, b1, l2, a2, b2), idx };\n                }\n            )) {\n                if (delta < smallestDelta) {\n                    smallestDelta = delta;\n                    smallestDeltaIdx = idx;\n                }\n            }\n            this.compressed[smallestDeltaIdx].count += v;\n            this.originalToCompressedMap.set(idx, smallestDeltaIdx);\n        }\n    }\n\n    /**\n     * Given color r, g, b, compute its saliency from the histogram.\n     * Saliency of a pixel is sum of its color distance with all other pixels\n     * instead of comparing every pair of pixels, we take distance against each histogram bucket,\n     * weighted by the size of its set\n     */\n    saliency(r: number, g: number, b: number) {\n        const pixelIndex = colorToIndex(r, g, b);\n        const compressedPixelIndex = this.originalToCompressedMap.get(pixelIndex)!;\n        return this.compressed.reduce((prev, cur, idx) => {\n            if (idx === compressedPixelIndex) {\n                return prev;\n            } else {\n                const [rh, gh, bh] = indexToColor[cur.originalIndex];\n                return prev + cur.count * diff(r, g, b, rh, gh, bh);\n            }\n        }, 0);\n    }\n}\n\n// Uses global perceptual contrast to detect salient regions,\n// implementation of the algorithm in the below paper:\n// M.-M. Cheng et al., \"Global Contrast based Salient Region Detection\", in IEEE CVPR, 2011\n// https://mmcheng.net/mftp/Papers/SaliencyTPAMI.pdf\nexport function findRegionsBySaliency(\n    canvas: CanvasType,\n    ctx: CanvasRenderingContext2D,\n    cutoffRatio: number,\n    invert: boolean\n) {\n    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    // cheng method quantizes 0, 255 range into 12 buckets for each of r,g,b\n    const colorHistogram: number[] = new Array(Math.pow(SALIENCY_BUCKETS, 3)).fill(0);\n    // group each pixel into histogram based by rgb value\n    for (let i = 0; i < data.data.length; i += 4) {\n        const [r, g, b] = data.data.slice(i, i + 3);\n        colorHistogram[colorToIndex(r, g, b)]++;\n    }\n    const histogram = new CompressedHistogram(colorHistogram);\n    const perPixelSaliency: number[] = new Array(canvas.width * canvas.height);\n    for (let i = 0; i < data.data.length; i += 4) {\n        const [r, g, b] = data.data.slice(i, i + 3);\n        perPixelSaliency[i / 4] = histogram.saliency(r, g, b);\n    }\n    const sortedPixels = perPixelSaliency\n        .concat()\n        .sort((a, b) => (invert ? a - b : b - a));\n    const cutoffValue = sortedPixels[Math.round(cutoffRatio * sortedPixels.length)];\n\n    return extractRunsByCutoff(data.width, data.height, (row, col) => {\n        const i = row * data.width + col;\n        return invert\n            ? perPixelSaliency[i] <= cutoffValue\n            : perPixelSaliency[i] >= cutoffValue;\n    });\n}\n","import { CodeGenerator } from '@babel/generator';\nimport { Node } from '@babel/types';\nimport {\n    SPACE_MARKER,\n    OPTIONAL_SPACE_MARKER,\n    UNBREAKABLE_SPACE_MARKER,\n} from './constants';\n\n/**\n * This class generates runnable JS code where replaceable whitespace is\n * annotated with special comments\n */\nexport class WhitespaceMarkerGenerator extends CodeGenerator {\n    constructor(ast: Node) {\n        // Concise replace newlines with spaces, which will let us insert more whitespace markers.\n        super(ast, { compact: true, comments: false });\n    }\n\n    generate() {\n        // @ts-ignore directly accessing the library's code, see https://git.io/J8Xf9\n        const g = this._generator;\n        const oldWord = g.word.bind(g);\n        g.word = (w: string) => {\n            oldWord(w);\n            if (\n                [\n                    'return',\n                    'break',\n                    'continue',\n                    'async',\n                    'throw',\n                    'yield',\n                    'await',\n                ].includes(w)\n            ) {\n                g._unbreakableSpace();\n            }\n        };\n        const oldUnaryExpression = g.UnaryExpression.bind(g);\n        g.UnaryExpression = (node: Node) => {\n            if (\n                'operator' in node &&\n                (node.operator === '+' || node.operator === '-')\n            ) {\n                // Require a space before unary exp because the last symbol could have been a postfix op\n                g._space();\n            }\n            oldUnaryExpression(node);\n        };\n        const oldUpdateExpression = g.UpdateExpression.bind(g);\n        g.UpdateExpression = (node: Node) => {\n            let isPostfix = false;\n            if ('prefix' in node && node.prefix) {\n                g._space();\n            } else {\n                isPostfix = true;\n            }\n            oldUpdateExpression(node);\n            if (isPostfix) {\n                g._space();\n            }\n        };\n        g.space = (force: boolean = false) => {\n            if (\n                (g._buf.hasContent() && !g.endsWith(' ') && !g.endsWith('\\n')) ||\n                force\n            ) {\n                g._space();\n            } else {\n                g._optionalSpace();\n            }\n        };\n        g._space = () => {\n            // This marks a location we can have 1 or more spaces or newline\n            g._append(SPACE_MARKER, true /* queue */);\n        };\n        g._optionalSpace = () => {\n            // This marks a location that can have 0 or more spaces or newline\n            g._append(OPTIONAL_SPACE_MARKER, true /* queue */);\n        };\n        g._unbreakableSpace = () => {\n            // This marks a location that must have a space and NOT a newline\n            g._append(UNBREAKABLE_SPACE_MARKER, true /* queue */);\n        };\n        const oldToken = g.token.bind(g);\n        g.token = (str: string) => {\n            if (str === '=>') {\n                g._unbreakableSpace();\n            }\n            oldToken(str);\n            // instead of smushing tokens together, mark the in-between as allowing spaces\n            g._optionalSpace();\n        };\n        return super.generate();\n    }\n}\n// TODO also deal with typescript(?)\n","import {\n    OPTIONAL_SPACE_MARKER,\n    SPACE_MARKER,\n    UNBREAKABLE_SPACE_MARKER,\n} from './constants';\n\nconst MAX_LINE_WIDTH = Number.MAX_SAFE_INTEGER;\n\n// Compute the minimum length of the code by replacing all spaces\n// with a single space and optional spaces with no space.\nexport function minCodeSize(tokens: TokenType[]): number {\n    return tokens.map(toStr).reduce((prev, cur) => prev + cur.length, 0);\n}\n\ntype SpaceType = 'opt' | 'req' | 'ubn';\ntype TokenType =\n    | {\n          space: SpaceType;\n      }\n    | {\n          text: string;\n      };\n\nfunction minWidth(t: TokenType): number {\n    if ('text' in t) {\n        return t.text.length;\n    } else if (t.space === 'opt') {\n        return 0;\n    }\n    return 1;\n}\n\nfunction toStr(t: TokenType): string {\n    if ('text' in t) {\n        return t.text;\n    } else if (t.space === 'opt') {\n        return '';\n    }\n    return ' ';\n}\n\nfunction isUbn(t: TokenType): boolean {\n    return 'space' in t && t.space === 'ubn';\n}\n\nexport function parseTokens(code: string) {\n    const tokens: TokenType[] = [];\n    for (const betweenBreaks of code.split(UNBREAKABLE_SPACE_MARKER)) {\n        const betweenSpaces = betweenBreaks.split(SPACE_MARKER);\n        for (const sp of betweenSpaces) {\n            const texts = sp.split(OPTIONAL_SPACE_MARKER);\n            for (const text of texts) {\n                tokens.push({ text });\n                tokens.push({ space: 'opt' });\n            }\n            tokens.push({ space: 'req' });\n        }\n        tokens.push({ space: 'ubn' });\n    }\n    return collapseTokens(tokens);\n}\n\n// Fold consecutive spaces to the strongest version\n// i.e. if I have opt - unbreakable - req - opt, then reduce them to one unbreakable\n// Also remove 'text' tokens with empty content and joins together consecutive 'text' nodes\n// At the end of this, the whole program should consist of alternating text-space tokens\nfunction collapseTokens(tokens: TokenType[]) {\n    const stronger = (a: TokenType, b: TokenType): SpaceType => {\n        if ('space' in a && 'space' in b) {\n            if (a.space === 'ubn' || b.space === 'ubn') {\n                return 'ubn';\n            } else if (a.space === 'req' || b.space === 'req') {\n                return 'req';\n            } else {\n                return 'opt';\n            }\n        }\n        throw new Error('unreachable statement');\n    };\n    const reducedTokens: TokenType[] = [];\n    for (let i = 0; i < tokens.length; i++) {\n        const lastToken = reducedTokens[reducedTokens.length - 1];\n        const curToken = tokens[i];\n        if ('text' in curToken && curToken.text === '') {\n            continue;\n        }\n        if (lastToken == null) {\n            reducedTokens.push(curToken);\n        } else if ('space' in lastToken && 'space' in curToken) {\n            lastToken.space = stronger(lastToken, curToken);\n        } else {\n            reducedTokens.push(curToken);\n        }\n    }\n    return reducedTokens;\n}\n\nexport function reshape(\n    tokens: TokenType[],\n    shapeFunction: (row: number) => number\n): string[] {\n    // Enforce a maximum on the line width, even if we get infinity or something from the fn\n    const shapeFn = (row: number) => Math.min(MAX_LINE_WIDTH, shapeFunction(row));\n    // First split the code into tokens that we can join together\n    const lines: TokenType[][] = [[]];\n    let currentLineWidth = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        const currentLineIndex = lines.length - 1;\n        const targetWidth = shapeFn(currentLineIndex);\n        // If the space is unbreakable or it's a token, we must continue this line\n        if (currentLineWidth === 0 || isUbn(t) || 'text' in t) {\n            lines[currentLineIndex].push(t);\n            currentLineWidth += minWidth(t);\n        } else {\n            // Otherwise, we're on a (required or optional) space and could break now\n            // to decide, we will look ahead to see if the next potential breakpoint\n            // would exceed our line's target width\n            let nextBreakpoint = 0;\n            for (let j = i + 1; j < tokens.length; j++) {\n                if ('space' in tokens[j] && !isUbn(tokens[j])) {\n                    break;\n                }\n                nextBreakpoint += minWidth(tokens[j]);\n            }\n            if (currentLineWidth + nextBreakpoint <= targetWidth) {\n                // 明天的烦恼交给明天 (https://youtu.be/8Q5HWGgT1M0)\n                lines[currentLineIndex].push(t);\n                currentLineWidth += minWidth(t);\n            } else {\n                // start a new line since the next break point would exceed the target\n                // Note: if this token is a required space, it becomes optional now\n                lines.push([{ space: 'opt' }]);\n                currentLineWidth = 0;\n            }\n        }\n    }\n    // This portion inserts whitespaces to justify each line to its target width\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        if (shapeFn(i) === MAX_LINE_WIDTH) {\n            // in this case we're putting everything on this line anyway,\n            // don't need to justify 2^53 times (probly not a good idea)\n            continue;\n        }\n        // target value - current size, i.e. number of spaces we want to add\n        let difference = Math.round(shapeFn(i) - minCodeSize(line));\n        // find indices in the line that are spaces\n        const spaceIndices = line\n            // (except last position because spaces at the end of a line aren't visible)\n            .slice(0, line.length - 1)\n            .map((t, idx) => ({ t, idx }))\n            .filter(({ t }) => 'space' in t)\n            .map(({ idx }) => idx);\n        // of course we can't enter the loop unless there are spaces on this line\n        while (spaceIndices.length > 0 && difference > 0) {\n            const idx = spaceIndices[Math.floor(spaceIndices.length * Math.random())];\n            // We've found the index to add space to, we can convert it to text because\n            // we no longer need to know that it was a space\n            line[idx] = { text: `${toStr(line[idx])} ` };\n            difference--;\n        }\n    }\n    return lines.map((line) => line.map(toStr).join(''));\n}\n"],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7VA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;AC3EA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AAAA;AAEA;;AAOA;AACA;AAQA;AACA;AACA;AAAA;AAEA;AACA;AACA;A;;;;;;;;;;;;;;;AC5DA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;AC9CA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAJA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;AClKA;AAEA;AAMA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;AClGA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;A","sourceRoot":""}