{"version":3,"file":"index.js","sources":["webpack:///./constants.ts","webpack:///./generator.ts","webpack:///./reshape.ts","webpack:///external \"@babel/generator\"","webpack:///external \"@babel/parser\"","webpack:///external \"lru-cache\"","webpack:///external \"node-canvas\"","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/ensure chunk","webpack:///webpack/runtime/get javascript chunk filename","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/require chunk loading","webpack:///./index.ts"],"sourcesContent":["import { Canvas } from 'node-canvas';\n\n// just some random UUID\nconst ID = '871dacbf-674c';\nexport const SPACE_MARKER = ` /*${ID}*/ `;\nexport const OPTIONAL_SPACE_MARKER = ` /*opt-${ID}*/ `;\nexport const UNBREAKABLE_SPACE_MARKER = ` /*ubn-${ID}*/ `;\n\n// This constant is a guess at a typical font's ratio of height:width\nexport const DEFAULT_HEIGHT_WIDTH_RATIO = 1.7;\n\nexport const DEFAULT_CUTOFF_THRESHOLD = 0.3;\n// Intensity values are sum of r, g, b at each pixel\nexport const INTENSITY_RANGE = 1 + 255 * 3;\n// Resize images to accomodate imperfect fill\nexport const SIZE_BUFFER_RATIO = 0.95;\n// 12 is value referenced in Cheng '11\nexport const SALIENCY_BUCKETS = 12;\n\nexport const MODES = ['intensity', 'saliency'] as const;\nexport type ModeType = typeof MODES[number];\nexport type CanvasType = Canvas | HTMLCanvasElement;\n","import { CodeGenerator } from '@babel/generator';\nimport { Node } from '@babel/types';\nimport {\n    SPACE_MARKER,\n    OPTIONAL_SPACE_MARKER,\n    UNBREAKABLE_SPACE_MARKER,\n} from './constants';\n\n/**\n * This class generates runnable JS code where replaceable whitespace is\n * annotated with special comments\n */\nexport class WhitespaceMarkerGenerator extends CodeGenerator {\n    constructor(ast: Node) {\n        // Concise replace newlines with spaces, which will let us insert more whitespace markers.\n        super(ast, { compact: true, comments: false });\n    }\n\n    generate() {\n        // @ts-ignore directly accessing the library's code, see https://git.io/J8Xf9\n        const g = this._generator;\n        const oldWord = g.word.bind(g);\n        g.word = (w: string) => {\n            oldWord(w);\n            if (\n                [\n                    'return',\n                    'break',\n                    'continue',\n                    'async',\n                    'throw',\n                    'yield',\n                    'await',\n                ].includes(w)\n            ) {\n                g._unbreakableSpace();\n            }\n        };\n        const oldUnaryExpression = g.UnaryExpression.bind(g);\n        g.UnaryExpression = (node: Node) => {\n            if (\n                'operator' in node &&\n                (node.operator === '+' || node.operator === '-')\n            ) {\n                // Require a space before unary exp because the last symbol could have been a postfix op\n                g._space();\n            }\n            oldUnaryExpression(node);\n        };\n        const oldUpdateExpression = g.UpdateExpression.bind(g);\n        g.UpdateExpression = (node: Node) => {\n            let isPostfix = false;\n            if ('prefix' in node && node.prefix) {\n                g._space();\n            } else {\n                isPostfix = true;\n            }\n            oldUpdateExpression(node);\n            if (isPostfix) {\n                g._space();\n            }\n        };\n        g.space = (force: boolean = false) => {\n            if (\n                (g._buf.hasContent() && !g.endsWith(' ') && !g.endsWith('\\n')) ||\n                force\n            ) {\n                g._space();\n            } else {\n                g._optionalSpace();\n            }\n        };\n        g._space = () => {\n            // This marks a location we can have 1 or more spaces or newline\n            g._append(SPACE_MARKER, true /* queue */);\n        };\n        g._optionalSpace = () => {\n            // This marks a location that can have 0 or more spaces or newline\n            g._append(OPTIONAL_SPACE_MARKER, true /* queue */);\n        };\n        g._unbreakableSpace = () => {\n            // This marks a location that must have a space and NOT a newline\n            g._append(UNBREAKABLE_SPACE_MARKER, true /* queue */);\n        };\n        const oldToken = g.token.bind(g);\n        g.token = (str: string) => {\n            if (str === '=>') {\n                g._unbreakableSpace();\n            }\n            oldToken(str);\n            // instead of smushing tokens together, mark the in-between as allowing spaces\n            g._optionalSpace();\n        };\n        return super.generate();\n    }\n}\n// TODO also deal with typescript(?)\n","import {\n    OPTIONAL_SPACE_MARKER,\n    SPACE_MARKER,\n    UNBREAKABLE_SPACE_MARKER,\n} from './constants';\n\nconst MAX_LINE_WIDTH = Number.MAX_SAFE_INTEGER;\n\n// Compute the minimum length of the code by replacing all spaces\n// with a single space and optional spaces with no space.\nexport function minCodeSize(tokens: TokenType[]): number {\n    return tokens.map(toStr).reduce((prev, cur) => prev + cur.length, 0);\n}\n\ntype SpaceType = 'opt' | 'req' | 'ubn';\ntype TokenType =\n    | {\n          space: SpaceType;\n      }\n    | {\n          text: string;\n      };\n\nfunction minWidth(t: TokenType): number {\n    if ('text' in t) {\n        return t.text.length;\n    } else if (t.space === 'opt') {\n        return 0;\n    }\n    return 1;\n}\n\nfunction toStr(t: TokenType): string {\n    if ('text' in t) {\n        return t.text;\n    } else if (t.space === 'opt') {\n        return '';\n    }\n    return ' ';\n}\n\nfunction isUbn(t: TokenType): boolean {\n    return 'space' in t && t.space === 'ubn';\n}\n\nexport function parseTokens(code: string) {\n    const tokens: TokenType[] = [];\n    for (const betweenBreaks of code.split(UNBREAKABLE_SPACE_MARKER)) {\n        const betweenSpaces = betweenBreaks.split(SPACE_MARKER);\n        for (const sp of betweenSpaces) {\n            const texts = sp.split(OPTIONAL_SPACE_MARKER);\n            for (const text of texts) {\n                tokens.push({ text });\n                tokens.push({ space: 'opt' });\n            }\n            tokens.push({ space: 'req' });\n        }\n        tokens.push({ space: 'ubn' });\n    }\n    return collapseTokens(tokens);\n}\n\n// Fold consecutive spaces to the strongest version\n// i.e. if I have opt - unbreakable - req - opt, then reduce them to one unbreakable\n// Also remove 'text' tokens with empty content and joins together consecutive 'text' nodes\n// At the end of this, the whole program should consist of alternating text-space tokens\nfunction collapseTokens(tokens: TokenType[]) {\n    const stronger = (a: TokenType, b: TokenType): SpaceType => {\n        if ('space' in a && 'space' in b) {\n            if (a.space === 'ubn' || b.space === 'ubn') {\n                return 'ubn';\n            } else if (a.space === 'req' || b.space === 'req') {\n                return 'req';\n            } else {\n                return 'opt';\n            }\n        }\n        throw new Error('unreachable statement');\n    };\n    const reducedTokens: TokenType[] = [];\n    for (let i = 0; i < tokens.length; i++) {\n        const lastToken = reducedTokens[reducedTokens.length - 1];\n        const curToken = tokens[i];\n        if ('text' in curToken && curToken.text === '') {\n            continue;\n        }\n        if (lastToken == null) {\n            reducedTokens.push(curToken);\n        } else if ('space' in lastToken && 'space' in curToken) {\n            lastToken.space = stronger(lastToken, curToken);\n        } else {\n            reducedTokens.push(curToken);\n        }\n    }\n    return reducedTokens;\n}\n\nexport function reshape(\n    tokens: TokenType[],\n    shapeFunction: (row: number) => number\n): string[] {\n    // Enforce a maximum on the line width, even if we get infinity or something from the fn\n    const shapeFn = (row: number) => Math.min(MAX_LINE_WIDTH, shapeFunction(row));\n    // First split the code into tokens that we can join together\n    const lines: TokenType[][] = [[]];\n    let currentLineWidth = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        const currentLineIndex = lines.length - 1;\n        const targetWidth = shapeFn(currentLineIndex);\n        // If the space is unbreakable or it's a token, we must continue this line\n        if (currentLineWidth === 0 || isUbn(t) || 'text' in t) {\n            lines[currentLineIndex].push(t);\n            currentLineWidth += minWidth(t);\n        } else {\n            // Otherwise, we're on a (required or optional) space and could break now\n            // to decide, we will look ahead to see if the next potential breakpoint\n            // would exceed our line's target width\n            let nextBreakpoint = 0;\n            for (let j = i + 1; j < tokens.length; j++) {\n                if ('space' in tokens[j] && !isUbn(tokens[j])) {\n                    break;\n                }\n                nextBreakpoint += minWidth(tokens[j]);\n            }\n            if (currentLineWidth + nextBreakpoint <= targetWidth) {\n                // 明天的烦恼交给明天 (https://youtu.be/8Q5HWGgT1M0)\n                lines[currentLineIndex].push(t);\n                currentLineWidth += minWidth(t);\n            } else {\n                // start a new line since the next break point would exceed the target\n                // Note: if this token is a required space, it becomes optional now\n                lines.push([{ space: 'opt' }]);\n                currentLineWidth = 0;\n            }\n        }\n    }\n    // This portion inserts whitespaces to justify each line to its target width\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        if (shapeFn(i) === MAX_LINE_WIDTH) {\n            // in this case we're putting everything on this line anyway,\n            // don't need to justify 2^53 times (probly not a good idea)\n            continue;\n        }\n        // target value - current size, i.e. number of spaces we want to add\n        let difference = Math.round(shapeFn(i) - minCodeSize(line));\n        // find indices in the line that are spaces\n        const spaceIndices = line\n            // (except last position because spaces at the end of a line aren't visible)\n            .slice(0, line.length - 1)\n            .map((t, idx) => ({ t, idx }))\n            .filter(({ t }) => 'space' in t)\n            .map(({ idx }) => idx);\n        // of course we can't enter the loop unless there are spaces on this line\n        while (spaceIndices.length > 0 && difference > 0) {\n            const idx = spaceIndices[Math.floor(spaceIndices.length * Math.random())];\n            // We've found the index to add space to, we can convert it to text because\n            // we no longer need to know that it was a space\n            line[idx] = { text: `${toStr(line[idx])} ` };\n            difference--;\n        }\n    }\n    return lines.map((line) => line.map(toStr).join(''));\n}\n","module.exports = require(\"@babel/generator\");;","module.exports = require(\"@babel/parser\");;","module.exports = require(\"lru-cache\");;","module.exports = require(\"node-canvas\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"loaded\", otherwise not loaded yet\nvar installedChunks = {\n\t\"index\": 1\n};\n\n// no on chunks loaded\n\nvar installChunk = (chunk) => {\n\tvar moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tfor(var i = 0; i < chunkIds.length; i++)\n\t\tinstalledChunks[chunkIds[i]] = 1;\n\n};\n\n// require() chunk loading for javascript\n__webpack_require__.f.require = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\tinstallChunk(require(\"./\" + __webpack_require__.u(chunkId)));\n\t\t} else installedChunks[chunkId] = 1;\n\t}\n};\n\n// no external install chunk\n\n// no HMR\n\n// no HMR manifest","import * as webpack from 'webpack';\nimport { DEFAULT_CUTOFF_THRESHOLD } from './constants';\n\nexport { reshape, minCodeSize, parseTokens } from './reshape';\nexport { WhitespaceMarkerGenerator } from './generator';\n\ntype OptionsInputType = {\n    imagePath: string;\n    cutoff?: number;\n    mode?: 'intensity' | 'saliency';\n    invert?: boolean;\n};\n\ntype OptionsType = {\n    imagePath: string;\n    cutoff: number;\n    mode: 'intensity' | 'saliency';\n    invert: boolean;\n};\n\nexport async function makeJsArt(\n    code: string,\n    options: OptionsInputType\n): Promise<string> {\n    const { cutoff, mode, invert, imagePath } = {\n        cutoff: options.cutoff || DEFAULT_CUTOFF_THRESHOLD,\n        mode: options.mode || 'intensity',\n        invert: options.invert || false,\n        ...options,\n    };\n    const { drawCode } = await import('./algos/entry-node');\n    return drawCode(code, imagePath, mode, cutoff, invert);\n}\n\nexport class MakeJsArtWebpackPlugin {\n    constructor(private options: OptionsInputType) {}\n\n    apply(compiler: webpack.Compiler) {\n        compiler.hooks.assetEmitted.tapAsync(\n            'MakeJsArtWebpackPlugin',\n            async (file, info, callback) => {\n                const { content, source, outputPath } = info;\n                console.log(file, source, outputPath);\n                if (this.options.imagePath) {\n                    const code = await makeJsArt(content.toString(), this.options);\n                    console.log(code);\n                }\n                callback();\n            }\n        );\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;A;;;;;;;;;;;;;;;ACrBA;AAEA;AAMA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;AClGA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;ACtKA;AACA;A;;;;;;;;ACDA;AACA;A;;;;;;;;ACDA;AACA;A;;;;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AAEA;AACA;AAgBA;;AAIA;AAMA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;A","sourceRoot":""}